# **Chapter 14 가상 메모리**

## 14-1 연속 메모리 할당

프로세스에 연속적인 메모리 공간을 할당하는 방식

### 스와핑

- 메모리 관리 기법
- 메모리에 적재된 프로세스들 중에 현재 실행되지 않는 프로세스들을 임시로 보조기억장치 일부 영역을 쫓아내고 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식
    - 스왑 영역
        - 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
    - 스왑 아웃
        - 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
    - 스왑 인
        - 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것
        - 스왑 아웃 → 스왑 인될 때는 다른 주소에 적재될 수 있다.

### 메모리 할당

프로세스는 메모리 내의 빈 공간에 적재되어야 한다. 메모리 내에 빈 공간이 여러 개 있다면 프로세스를 어디에 배치해야 할까?

**비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식**

- 최초 적합
    - 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화할 수 있고 결과적으로 빠른 할당이 가능하다.
- 최적 적합
    - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식
- 최악 적합
    - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식

### 외부 단편화

연속 메모리 할당은 외부 단편화라는 문제를 내포하고 있다.

- 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이에 빈 공간들이 생긴다. 결국 큰 프로세스를 적재하기 어려운 상황을 초래하고 메모리 낭비로 이어지는 현상
- 해결 방안
    - 압축
        - 메모리 조각 모음
        - 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
        - 재배치 → 작은 빈 공간들을 하나의 큰 빈 공간으로 만든다.
        - 단점
            - 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 한다.
            - 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드 야기
            - 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하여 압축할 수 있는지에 대한 명확한 방법을 결정하기가 어려운데, 이에 대한 메모리 기법이 **페이징 기법**이다.

> 연속 메모리 할당 → 외부 단편화 문제 발생 → 압축 → 페이징 기법
>

## 14-2 페이징을 통한 가상 메모리 관리

프로세스를 메모리에 연속적으로 할당하는 방식의 두 가지 문제점

1. 외부 단편화
2. 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점
    - 가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
        - 이를 가능케 하는 가상 메모리 관리 기법에 **페이징**과 세그멘테이션이 있다.
            - 현대에는 페이징 기법을 대부분 사용한다.
                - 물리 메모리보다 큰 프로세스를 실행할 수 있다.
                - 외부 단편화 문제 해결

### 페이징이란

외부 단편화가 생긴 근본적인 이유는? 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문

- 페이징은 프로세스의 논리 주소 공간을 **페이지**라는 일정한 단위로 자르고, 메모리의 물리 주소 공간을 **프레임**이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 **페이지를 프레임에 할당하는 가상 메모리 관리 기법**이다.
    - 페이지 아웃
        - 페이징 시스템에서의 스왑 아웃
    - 페이지 인
- 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 모메리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.

### 페이지 테이블

프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서는 ‘다음에 실행할 명령어 위치’를 찾기가 어려워진다.

- 이를 해결하기 위해, 페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리주소에는 연속적으로 배치되도록 페이지 테이블을 이용한다.
    - 물리 주소: 실제 메모리 주소
    - 논리 주소: CPU가 바라보는 주소
- 페이지 번호와 프레임 번호를 짝지어주는 일종의 이정표
    - 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.

> 페이징은 외부 단편화 문제를 해결할 수 있지만 메모리 낭비인 **내부 단편화**라는 문제를 야기할 수 있다.
>

### 페이징에서의 주소 변환

- 특정 주소에 접근하려면 필요한 두 가지
    - 어떤 페이지 혹은 프레임에 접근하고 싶은지
    - 접근하련느 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호(page number)와 변위(offset)로 이루어져 있다.

### 페이지 테이블 엔트리

- 페이지 테이블의 각각의 행들을 페이지 테이블 엔트리라고 한다.
- 구성 요소
    - 페이지 번호
    - 프레임 번호
    - 유효 비트
        - 해당 페이지가 메모리에 적재되어 있는지 여부를 알려주는 비트
        - 페이지가 메모리에 적재되어 있지 않으면 페이지 폴트(예외,Exception)가 발생한다.
    - 보호 비트
        - 페이지에 접근할 권한을 제한하여 페이지를 보호하는 비트
    - 참조 비트
        - 페이지에 접근한 적이 있는지를 나타낸다.
    - 수정 비트
        - 해당 페이지가 수정된 적이 있는지를 나타낸다.
        - 왜 존재할까? 페이지가 메모리에 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재한다.

## 14-3 페이지 교체와 프레임 할당

**물리 메모리의 크기는 한정**되어 있기 때문에, 운영체제는 프로세스들이 한정된 메모리를 효율적으로 이용할 수 있도록 기존 메모리에 적재된 **불필요한 페이지를 선별하여 보조기억장치로 내보낼 수 있어야** 하고, 프로세스들에 **적절한 수의 프레임을 할당하여 페이지를 할당할 수 있게 해야** 한다.

### 요구 페이징

- 페이지가 필요할 때만 메모리에 적재하는 기법

### 페이지 교체 알고리즘

- 쫓아낼 페이지를 결정하는 방법
- 좋은 페이지 교체 알고리즘은?
    - 페이지 폴트를 가장 적게 일으키는 알고리즘
        - 페이지 폴트가 일어나면 보조기억장치로부터 필요한 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문
- FIFO 페이지 교체 알고리즘
    - 가장 먼저 올라온 페이지부터 내쫓는 방식
    - 구현은 간단하지만 부작용도 있다. 실행된 이후로 사용되지 않을 페이지도 있지만 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있다.
- 최적 페이지 교체 알고리즘
    - CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘
    - 앞으로의 사용 빈도가 가장 낮은 페이지를 교체
    - 구현이 어렵다. 따라서 이론상 성능을 평가하기 위한 목적으로 사용된다.
        - 최적 페이지 교체 알고리즘을 실행했을 때 발생하는 페이지 폴트 횟수를 페이지 폴트의 하한선으로 간주하고, 최적 페이지 교체 알고리즘에 비해 얼만큼 페이지 폴트 횟수가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용한다.
- LRU 페이지 교체 알고리즘(Least Recently Used Page Replacement Algorithm)
    - 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘

### 스래싱과 프레임 할당

- 스래싱(thrashing)
    - 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
    - 지나치게 빈번한 페이지 교체로 인해 CPU 이용률이 낮아지는 문제를 뜻한다.
- 프레임 할당 방식
    - 균등 할당
        - 모든 프로세스에 동일한 프레임을 배분하는 방식
    - 비례 할당
        - 프로세스 크기에 따라 프레임을 배분하는 방식
- 프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식
    - 작업 집합 모델
    - 페이지 폴트 빈도

---

### 논의 내용

- 페이지 교체 알고리즘을 왜 사용할까요?