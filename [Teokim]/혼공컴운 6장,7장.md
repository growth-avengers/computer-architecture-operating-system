# ch06. CPU 성능 향상 기법
## 06-1 RAM의 특성과 종류
### RAM은 휘발성 저장 장치이고, 보조기억장치는 비휘발성 저장 장치이다

### RAM의 용량과 성능
- 비싼 RAM을 쓴다면 많은 프로그램들을 동시에 실행하는데에 유리하다
    
### DRAM(Dynamic RAM)
- Dynamic = '동적의'
- 저장된 데이터가 동적으로 사라지는 RAM
- 데이터 소멸을 막기 위해 주기적으로 재활성화 해야함
- 일반적으로 메모리로 사용되는 RAM
  - 상대적으로 소비전력이 낮고 저렴하고 집적도가 높아 대용량 설계가 용이

### SRAM(Static RAM)
- Static='정적의'
- 저장된 데이터가 정적인 RAM
- DRAM보다 일반적으로 더 빠름
- 일반적으로 캐시 메모리에서 사용되는 RAM
  - 상대적으로 소비전력이 높고 가격이 높고 집적도가 낮아
  - '대용량으로 설계할 필요는 없으나 빨라야하는 장치에 사용'

### SDRAM(Synchronous DRAM)
- 특별한 DRAM
- 클럭 신호와 동기화된 DRAM

### DDR SDRAM(Double Data Rate SDRAM)
- 대역폭은 데이터를 주고받는 길의 널비
- DDR SDRAM은 대역폭이 두 배 넓은 SDRAM이다
- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM

## 06-2 메모리의 주소 공간 
메모리는 크게 논리 주소와 물리 주소로 나뉜다.

### 물리 주소와 논리 주소

메모리에 저장된 값들은 시시각각 변한기때문에 논리 주소와 물리 주소로 나누었다
1. 새롭게 실행되는 프로그램은 새롭게 메모리에 적재
2. 실행이 끝난 프로그램은 메모리에서 삭제
3. 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소는 달라짐

### 물리 주소

1. 메모리 입장에서 바라본 주소
2. 말 그대로 정보가 실제로 저장된 하드웨어상의 주소

### 논리 주소

1. CPU와 실행 중인 프로그램 입장에서 바라본 주소
2. 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소

메모리가 CPU와 상호작용하기위해는 변환과정이 필요하다
그렇다면 물리 주소와 논리 주소간의 변환은 어떻게 이루어질까?

mmu : 메모리 관리 장치 
- 논리주소 -> 물리주소로 변환

### mmu
mmu는 논리 주소와 베이스 레지스터(프로그램의 기준주소) 값을 더하여
논리 주소를 물리 주소로 변환
- 프로그램의 가장 작은 물리 주소를 저장하는 셈
- 프로그램의 시작점으로부터 떨어진 거리인 셈

### 메모리 보호

한계 레지스터
1. 프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음
2. 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, 한계 레지스터는 
논리 주소의 최대 크기를 저장
3. 베이스 레지스터 값 <= 프로그램의 물리 주소 범위 < 베이스 레지스터 + 한계 레지스터 값

이처럼 CPU는 메모리에 접근하기 전 접근하고자 하는 논리 주소가 한계 레지스터보다
작은지를 항상 검사
실행 중인 프로그램의 독립적인 실행공간을 확보
하나의 프로그램이 다른 프로그램에 침범하지 못하게 보호

- 파이프라인 중단 방지를 위해 명령어 순차 처리 하지 않는 방식

## 06-3 다양한 보조기억장치

CPU가 메모리에 접근하는 시간은 CPU 연산 속도보다 느리다
속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다

### 캐시 메모리
1. CPU와 메모리 사이에 위치한
레지스터보다 용량이 크고 메모리보다 빠른 SRAM기반의 저장 장치
2. CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 탄생
3. CPU가 매번 메모리에 왔다갔다하는 건 시간이 오래 걸리니,
메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 쓰자

참조 지역성의 원리
1. 캐시 메모리는 메모리보다 용량이 작다
2. 당연하게도 메모리의 모든 내용을 저장할 수 없다
3. CPU가 자주 사용할 법한 내용을 예측하여 저장

# 내 생각
소프트웨어적인 캐싱에 대해서는 익숙했는데 하드웨어적으로 다시 한번 접근하여
숙지를 해보니 이해가 더욱 잘되었다
# 논의할 내용
다른 분들의 캐싱 경험을 듣고싶습니다

# ch07. 하드 디스크
## 07-1 다양한 보조기억장치(하드 디스크와 플래시 메모리)
### 하드 디스크
1. 기본적으로 트랙과 섹터단위로 데이터 저장
2. 섹터의 크기 : 512 바이트~4096바이트
3. 하나 이상의 섹터를 묶어 블록이라고 표현하기도 한다

### 실린더
- 여러 겹의 플래터 상에서 같은 트랙이 위치 한 곳을 모아 연결한 논리적 단위
- 연속된 정보는 한 실린더에 기록

### 데이터 접근 과정
- 탐색 시간 : 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는시간
- 회전 지연 : 헤드가 있는 곳으로 플래터를 회전시키는 시간
- 전송 시간 : 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간

### 페이지의 상태
- Free 상태 : 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
- Valid 상태 : 이미 유효한 데이터를 저장하고 있는 상태
- Invalid 상태 : 유효하지 않는 데이터를 저장하고 있는 상태

## 07-2 RAID의 정의와 종류
#### RAID란?
- 하드 디스크와 SSD로 사용하는 기술
- 데이터의 안전성 혹은 높은 성능을 위해 여러 물리적 보조기억장치를
마치 하나의 논리적 보조기억장치처럼 사용하는 기술

### RAID 0
- 각 하드 디스크는 번갈아 가며 데이터를 저장합니다
- 저장되는 데이터가 하드 디스크 개수만큼 나뉘어 저장
- 스트라입 : 마치 줄무늬처럼 분산되어 저장된 데이터
- 스트라이핑 : 분산하여 자장하는 것
- 장점 : 입출력 속도의 향상
- 단점 : 저장된 정보가 안전하지 않음
### RAID1
- 미러링 : 복사본을 만드는 방식
- 데이터를 쓸 때 원본과 복사본 두 군데에 씀
- 단점 : 하드 디스크 개수가 한정되었을 때 사용 가능한
용량이 적어짐
- 백업복사본이 있기때문에 비교적 안전함
### RAID4
- 오류를 검출하고 복수하기 위한 정보를 저장
- 패리티 비트를 저장
- 단점 : 패리티 디스크의 병목
### RAID5
- 패리티 정보를 분산하여 저장하는 방식
### RAID6
- 오류를 검출하고 복구할 수 있는 수단


## 07-3 장치 컨트롤러와 장치 드라이버

### CPU-입출력장치 정보 주고받기
- 첫째, 입출력장치에는 종류가 너무나도 많다
장치가 다양하면 장치마다 속도, 데이터 전송 형식 등도 다양하다
- 둘째, 일반적으로 CPU와 메모리의 데이터 전송률은 높지만
입출력장치의 데이터 전송률은 낮다

### 장치 컨트롤러
- 이러한 이유로 입출력 장치는 장치 컨트롤러를 통해 컴퓨터와 연결된다
- CPU와 입출력장치 간의 통신중개
- 오류 검출과 데이터 버퍼링

### 장치 컨트롤러의 구조
- 데이터 레지스터 : CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터
- RAM을 사용하기도
- 상태 레지스터 : 상태 정보 저장
- 입출력장치가 입출력 작업을 할 준비가 되었는지,
- 입출력 작업이 완료되었는지,
- 입출력장치에 오류는 없는지 등의 상태 정보
- 제어 레지스터
- 입출력장치가 수행할 내용에 대한 제어 정보

# 내 생각
하드웨어와 운영체제의 연결방식을 알게된 계기가 되었습니다
# 논의할 내용
컴퓨터 구조가 마무리가 되었습니다. 컴퓨터구조가 웹을 이해하는데 도움이 많이되었는지 논의해봅시다~