# 14-1 연속 메모리 할당
프로세스에 연속적인 메모리 공간을 할당하는 방식을 연속 메모리 할당 방식이라고 합니다.

## 스와핑
프로세스들을 임시로 보조 기억장치 일부 영역으로 쫓아내고, 그렇게 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 스와핑이라고 합니다.

- 스왑 영역
	- 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑  아웃
	- 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인
	- 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨지는 것

## 메모리 할당
프로세스 메모리 내의 빈 공간에 적재되어야 한다.
최초 적합, 최적 적합, 최악 적합이 있다.
- 최초 적합
	- 운영 체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간ㅡㄹ 프로세스를 배치하는 방식
- 최적 적합
	- 운영 체제가 빈 공간을  모두 검색해 본 후, 프로세스가 적재 될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식
- 최악 적합
	-  운영 체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식

## 외부  단편화
연속 메모리 할당은 외부 단편화라는 문제를 내포하고 있다.
외부 단편화는 프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다.

외부 단편화를 해결하는 방법 압축하는 방법이 있다.
외부 단편화를 없앨 수 있는 다른 해결 방안은 가상 메모리 기법, 페이징이 있다.

# 14-2 페이징을 통한 가상 메모리 관리
외부 단편화의 문제를 해결 하기 위해서 페이지이 기법을 이용하면 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만 아니라 외부 단편화 문제를 해결 할 수 있습니다.
## 페이징이란?
만일 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 외부 단편화 문제를 해결할 수 있습니다.
페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법입니다.

페이징에는 스와핑을 사용 할 수 있습니다. 그 중에서 페이징 **스왑 아웃/스왑 인**이 있습니다.
페이징 시스템에서는 페이지 아웃, 스왑 인은 페이징 인이라고 부릅니다.
한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없습니다. 그래서 프로세스를 이루는 페이지 중에 실행에 필요한 일부 페이지만 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 필요가 있습니다.

## 페이지  테이블
프로세스가 메모리에 불연속으로 배치되어 있다면 CPU는 순차적으로 실행 시키기 어렵습니다. 이를 해결하기 위해서 물리 주소에 불연석적으로 배치되더라고 논리 주소에는 연속적으로 배치되도록 **페이지 테이블**을 이용합니다.
페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 이정표입니다. CPU는 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있습니다.
CPU 입자에서 바라본 논리 주소는 연속적으로 보일 수 있습니다. 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행합니다.

## 페이징에서의 주소 변환
페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호와 변위로 이루어져 있습니다.

## 페이지 테이블 엔트리
페이지 테이블의 각 엔트리, 다시 말해 페이지 테이블의 각각의 행들을 **페이지 테이블 엔트리**라고 합니다.

### 유효 비트
유효 비트는 현재 해당 페이지에 접근 가능여부를 알려줍니다.
만일 CPU 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 어떻게 될까요? 이 경우 **페이지 폴트**라는 예외가 발생합니다.

### 보호 비트
페이지 보호 기능을 위해 존재하는 비트입니다.

### 수정 비트
해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려줍니다. 더티 비트라고 부릅니다.

# 14-3 페이지 교체와 프레임 할당
운영체제는 프로세스들이 한정된 메모리를 효율적으로 이용할 수 있도록 기존에 메모리에 적재된 불필요한 페이지를 선별하여 보조기억장치로 내보낼 수 있어야 합니다.
프로세스들에 적절한 수의 프레임을 할당하여 페이지를 할당할 수 있게 해야 합니다.

## 요구 페이징
프로세스르 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법을 **요구 페이징**이라고 합니다.

요구 페이징 기법은 다음과 같습니다.
1. CPU가 특정 페이지에 접근하는 명령어 입니다.
2. 해당 페이지가 현재 메모리에 있을 경우 CPU는 페이지가 적재된 프레임에 접근합니다.
3. 해당 페이지가 현재 메모리에 없을 경우 페이지 폴트가 발생합니다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정합니다.
5. 1번을 다시 수행합니다.

요구 페이징 시스템이 안정적으로 작동하려면 필연적으로 두 가지를 해결해야 합니다.
1. 페이지 교체
2. 프레임 할당

이를 결정하는 방법이 페이지 교체 알고리즘입니다.
쫓아낼 페이지를 결정하는 방법을 페이지 교체 알고리즘이라고 합니다.

## 페이지 교체 알고리즘
페이지 교체 알고리즘을 제대로 이해하려면 페이지 폴트 횟수를 알 수 있어야 합니다.
페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있어야 합니다.

연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위 페이지 폴트를 발생시키지 않기 때문입니다.

### FIFO 페이지 교체 알고리즘
FIFO 페이지 교체 알고리즘(`First-In First-Out Page Replacement Algorithm`) 입니다.

### 최적 페이지 교체 알고리즘
최적 페이지 교체 알고리즘 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘입니다.
FIFO 알고리즘에 비해면 페이지 폴트 빈도가 훨씬 낮아진 것을 확인 할 수 있습니다.
최적 페이지 교체 알고리즘은 이름 그대로 가장 낮은 페이지 폴트율을 보장하는 알고리즘입니다.

### LRU 페이지 교체 알고리즘
이 알고리즘 LRU 페이지 교체 알고리즘(`Least Recently Used Replacement Alogorithm`)입니다.
LRU 페이지 교체 알고리즘은 '최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것'이라는 아이디어를 토대로 만들어진 알고리즘입니다.

## 스래싱과 프레임 할당
프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생합니다.
프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수밖에 없습니다. 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소유하여 성능이 저해되는 문제 스래싱(`thrashing`)이라고 입니다.

메모리에서 동시 실행되는 프로세스의 수를 멀티프로그래밍의 정도라고 합니다.
스레싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문입니다.